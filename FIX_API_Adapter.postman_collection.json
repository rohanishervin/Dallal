{
	"info": {
		"_postman_id": "b8c4d7e1-4a89-4c2b-9f14-8d7e6f3a2b5c",
		"name": "FIX API Adapter - Complete Collection",
		"description": "Complete Postman collection for testing FIX API Adapter endpoints.\n\n## Authentication Flow\n1. First run **Login** to get JWT token\n2. Token is automatically saved to environment variable `auth_token`\n3. All protected endpoints use this token automatically\n\n## Available Endpoints\n- Authentication (login)\n- Session management (status, logout)\n- Market data (instruments, historical bars)\n- **NEW: Complete Trading System** üéØ\n  - Market orders (immediate execution)\n  - Limit orders (execute at specified price)\n  - Stop orders (trigger at stop price)\n  - Stop-limit orders (trigger + limit protection)\n  - Order cancellation and modification\n- WebSocket orderbook streaming\n- Health checks\n\n## Environment Variables\n- `base_url`: API base URL (default: http://localhost:8000)\n- `ws_base_url`: WebSocket base URL (default: ws://localhost:8000)\n- `auth_token`: JWT token (auto-set after login)\n- `username`: Your FIX username\n- `password`: Your FIX password\n- `device_id`: Optional device identifier\n\n## New in this version\n- **üöÄ COMPLETE TRADING SYSTEM**: All 4 order types with full FIX protocol integration\n- **üìä Order Management**: Cancel and modify pending orders\n- **üõ°Ô∏è Advanced Features**: Stop loss, take profit, time-in-force options\n- **üíº Order Metadata**: Comments, tags, magic numbers for order tracking\n- **‚ö° Process Isolation**: Thread-safe QuickFIX integration\n- **üîí Security**: JWT authentication with comprehensive validation\n- **WebSocket Orderbook**: Real-time orderbook streaming\n- **Historical Bars**: OHLCV data with multiple timeframes\n\n## Trading Order Types\n1. **Market Orders**: Immediate execution at current market price\n2. **Limit Orders**: Execute at specified price or better\n3. **Stop Orders**: Trigger at stop price, then become market order\n4. **Stop-Limit Orders**: Trigger at stop price, then become limit order\n\n## WebSocket Usage\nUse external WebSocket clients (e.g., WebSocket King, wscat) to connect:\n```\nws://localhost:8000/ws/orderbook?token=YOUR_JWT_TOKEN\n```\nSend JSON messages:\n```json\n{\"type\": \"subscribe\", \"symbol\": \"EUR/USD\", \"levels\": 5}\n{\"type\": \"unsubscribe\", \"symbol\": \"EUR/USD\"}\n```",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
		"_exporter_id": "12345678"
	},
	"item": [
		{
			"name": "üîê Authentication",
			"item": [
				{
					"name": "Login",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"// Test response status",
									"pm.test(\"Status code is 200\", function () {",
									"    pm.response.to.have.status(200);",
									"});",
									"",
									"// Parse response",
									"const response = pm.response.json();",
									"",
									"// Test response structure",
									"pm.test(\"Response has required fields\", function () {",
									"    pm.expect(response).to.have.property('success');",
									"    pm.expect(response).to.have.property('message');",
									"});",
									"",
									"// If login successful, save token",
									"if (response.success && response.token) {",
									"    pm.test(\"Login successful\", function () {",
									"        pm.expect(response.success).to.be.true;",
									"        pm.expect(response.token).to.be.a('string');",
									"    });",
									"    ",
									"    // Save token to environment variable",
									"    pm.environment.set(\"auth_token\", response.token);",
									"    console.log(\"‚úÖ Auth token saved:\", response.token.substring(0, 20) + \"...\");",
									"} else {",
									"    pm.test(\"Login failed as expected\", function () {",
									"        pm.expect(response.success).to.be.false;",
									"        pm.expect(response.error).to.be.a('string');",
									"    });",
									"    console.log(\"‚ùå Login failed:\", response.error);",
									"}",
									"",
									"// Log response for debugging",
									"console.log(\"üìã Full response:\", JSON.stringify(response, null, 2));"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Clear any existing token before login",
									"pm.environment.unset(\"auth_token\");",
									"console.log(\"üîÑ Starting fresh login attempt...\");"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"username\": \"{{username}}\",\n  \"password\": \"{{password}}\",\n  \"device_id\": \"{{device_id}}\"\n}"
						},
						"url": {
							"raw": "{{base_url}}/auth/login",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"auth",
								"login"
							]
						},
						"description": "Authenticate user with FIX credentials and receive JWT token.\n\n**Rate Limited**: 5 attempts per minute per IP\n\n**Creates dual FIX sessions**:\n- Trade session (port 5004)\n- Feed session (port 5005)\n\n**Environment Variables Required**:\n- `username`: Your FIX trading username\n- `password`: Your FIX trading password\n- `device_id`: Optional device identifier"
					},
					"response": [
						{
							"name": "Successful Login",
							"originalRequest": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"username\": \"trader123\",\n  \"password\": \"password123\",\n  \"device_id\": \"postman_testing\"\n}"
								},
								"url": {
									"raw": "{{base_url}}/auth/login",
									"host": [
										"{{base_url}}"
									],
									"path": [
										"auth",
										"login"
									]
								}
							},
							"status": "OK",
							"code": 200,
							"_postman_previewlanguage": "json",
							"header": [
								{
									"key": "Content-Type",
									"value": "application/json"
								}
							],
							"cookie": [],
							"body": "{\n    \"success\": true,\n    \"token\": \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ0cmFkZXIxMjMiLCJpYXQiOjE2NDA5OTUyMDAuMCwiZXhwIjoxNjQwOTk4ODAwLjAsImp0aSI6IjEyMzQ1Njc4LTkwYWItY2RlZi0xMjM0LTU2Nzg5MGFiY2RlZiJ9.example_signature\",\n    \"message\": \"Login successful\"\n}"
						},
						{
							"name": "Failed Login",
							"originalRequest": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"username\": \"invalid\",\n  \"password\": \"wrong\"\n}"
								},
								"url": {
									"raw": "{{base_url}}/auth/login",
									"host": [
										"{{base_url}}"
									],
									"path": [
										"auth",
										"login"
									]
								}
							},
							"status": "OK",
							"code": 200,
							"_postman_previewlanguage": "json",
							"header": [
								{
									"key": "Content-Type",
									"value": "application/json"
								}
							],
							"cookie": [],
							"body": "{\n    \"success\": false,\n    \"error\": \"Invalid credentials\",\n    \"message\": \"Login failed\"\n}"
						}
					]
				}
			],
			"description": "Authentication endpoints for user login and JWT token management."
		},
		{
			"name": "üìä Session Management",
			"item": [
				{
					"name": "Get Session Status",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"// Test response status",
									"pm.test(\"Status code is 200\", function () {",
									"    pm.response.to.have.status(200);",
									"});",
									"",
									"// Parse response",
									"const response = pm.response.json();",
									"",
									"// Test response structure",
									"pm.test(\"Response has required fields\", function () {",
									"    pm.expect(response).to.have.property('success');",
									"    pm.expect(response).to.have.property('session');",
									"    pm.expect(response).to.have.property('message');",
									"});",
									"",
																	"// Test session object",
								"pm.test(\"Session object is valid\", function () {",
								"    pm.expect(response.session).to.have.property('user_id');",
								"    pm.expect(response.session).to.have.property('overall_active');",
								"});",
								"",
								"// Log session info",
								"if (response.session.overall_active) {",
								"    console.log(\"‚úÖ Active sessions:\", response.message);",
								"    ",
								"    // Log Trade session details",
								"    if (response.session.trade_session) {",
								"        const trade = response.session.trade_session;",
								"        console.log(\"üìä Trade Session:\");",
								"        console.log(\"  - Active:\", trade.is_active);",
								"        console.log(\"  - Age:\", trade.session_age_seconds, \"seconds\");",
								"        console.log(\"  - Heartbeat:\", trade.heartbeat_status);",
								"        console.log(\"  - Last heartbeat:\", trade.last_heartbeat || 'Never');",
								"    }",
								"    ",
								"    // Log Feed session details",
								"    if (response.session.feed_session) {",
								"        const feed = response.session.feed_session;",
								"        console.log(\"üìà Feed Session:\");",
								"        console.log(\"  - Active:\", feed.is_active);",
								"        console.log(\"  - Age:\", feed.session_age_seconds, \"seconds\");",
								"        console.log(\"  - Heartbeat:\", feed.heartbeat_status);",
								"        console.log(\"  - Last heartbeat:\", feed.last_heartbeat || 'Never');",
								"    }",
								"} else {",
								"    console.log(\"‚ùå No active sessions found\");",
								"}",
								"",
								"console.log(\"üìã Full session details:\", JSON.stringify(response.session, null, 2));"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{auth_token}}",
									"type": "string"
								}
							]
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{base_url}}/session/status",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"session",
								"status"
							]
						},
						"description": "Get current session status including both Trade and Feed sessions.\n\n**Authentication Required**: JWT token in Authorization header\n\n**Returns**:\n- Session activity status\n- Creation time and last activity\n- Session age in seconds\n- Which sessions are active (Trade/Feed)"
					},
					"response": [
						{
							"name": "Active Sessions",
							"originalRequest": {
								"method": "GET",
								"header": [
									{
										"key": "Authorization",
										"value": "Bearer {{auth_token}}"
									}
								],
								"url": {
									"raw": "{{base_url}}/session/status",
									"host": [
										"{{base_url}}"
									],
									"path": [
										"session",
										"status"
									]
								}
							},
							"status": "OK",
							"code": 200,
							"_postman_previewlanguage": "json",
							"header": [
								{
									"key": "Content-Type",
									"value": "application/json"
								}
							],
							"cookie": [],
							"body": "{\n    \"success\": true,\n    \"session\": {\n        \"user_id\": \"trader123\",\n        \"overall_active\": true,\n        \"trade_session\": {\n            \"connection_type\": \"trade\",\n            \"is_active\": true,\n            \"created_at\": \"2023-12-01T10:30:00Z\",\n            \"last_activity\": \"2023-12-01T10:35:00Z\",\n            \"last_heartbeat\": \"2023-12-01T10:35:30Z\",\n            \"session_age_seconds\": 300,\n            \"heartbeat_status\": \"healthy\"\n        },\n        \"feed_session\": {\n            \"connection_type\": \"feed\",\n            \"is_active\": true,\n            \"created_at\": \"2023-12-01T10:30:05Z\",\n            \"last_activity\": \"2023-12-01T10:35:05Z\",\n            \"last_heartbeat\": \"2023-12-01T10:35:35Z\",\n            \"session_age_seconds\": 295,\n            \"heartbeat_status\": \"healthy\"\n        }\n    },\n    \"message\": \"Trade session active (heartbeat: healthy), Feed session active (heartbeat: healthy)\"\n}"
						}
					]
				},
				{
					"name": "Logout Session",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"// Test response status",
									"pm.test(\"Status code is 200\", function () {",
									"    pm.response.to.have.status(200);",
									"});",
									"",
									"// Parse response",
									"const response = pm.response.json();",
									"",
									"// Test response structure",
									"pm.test(\"Response has required fields\", function () {",
									"    pm.expect(response).to.have.property('success');",
									"    pm.expect(response).to.have.property('message');",
									"});",
									"",
									"// Test logout success",
									"pm.test(\"Logout successful\", function () {",
									"    pm.expect(response.success).to.be.true;",
									"});",
									"",
									"console.log(\"üîì Logout result:\", response.message);"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{auth_token}}",
									"type": "string"
								}
							]
						},
						"method": "POST",
						"header": [],
						"url": {
							"raw": "{{base_url}}/session/logout",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"session",
								"logout"
							]
						},
						"description": "Logout and cleanup both Trade and Feed FIX sessions.\n\n**Authentication Required**: JWT token in Authorization header\n\n**Actions**:\n- Sends proper FIX logout messages\n- Closes SSL connections\n- Removes sessions from memory\n- Stops heartbeat monitoring"
					},
					"response": [
						{
							"name": "Successful Logout",
							"originalRequest": {
								"method": "POST",
								"header": [
									{
										"key": "Authorization",
										"value": "Bearer {{auth_token}}"
									}
								],
								"url": {
									"raw": "{{base_url}}/session/logout",
									"host": [
										"{{base_url}}"
									],
									"path": [
										"session",
										"logout"
									]
								}
							},
							"status": "OK",
							"code": 200,
							"_postman_previewlanguage": "json",
							"header": [
								{
									"key": "Content-Type",
									"value": "application/json"
								}
							],
							"cookie": [],
							"body": "{\n    \"success\": true,\n    \"message\": \"Trade session, Feed session logged out successfully\"\n}"
						}
					]
				}
			],
			"description": "Session management endpoints for monitoring and controlling FIX sessions."
		},
		{
			"name": "üìà Market Data",
			"item": [
				{
					"name": "Get Trading Instruments",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"// Test response status",
									"pm.test(\"Status code is 200\", function () {",
									"    pm.response.to.have.status(200);",
									"});",
									"",
									"// Parse response",
									"const response = pm.response.json();",
									"",
									"// Test response structure",
									"pm.test(\"Response has required fields\", function () {",
									"    pm.expect(response).to.have.property('success');",
									"    pm.expect(response).to.have.property('request_id');",
									"    pm.expect(response).to.have.property('symbols');",
									"});",
									"",
									"// Test if request was successful",
									"if (response.success) {",
									"    pm.test(\"Security list retrieved successfully\", function () {",
									"        pm.expect(response.success).to.be.true;",
									"        pm.expect(response.symbols).to.be.an('array');",
									"    });",
									"    ",
									"    console.log(\"‚úÖ Retrieved\", response.symbols.length, \"trading instruments\");",
									"    console.log(\"üìä Request ID:\", response.request_id);",
									"    ",
									"    // Log first few symbols",
									"    if (response.symbols.length > 0) {",
									"        console.log(\"üìã Sample instruments:\");",
									"        response.symbols.slice(0, 5).forEach((symbol, index) => {",
									"            console.log(`${index + 1}. ${symbol.symbol} - ${symbol.description || 'No description'}`);",
									"        });",
									"    }",
									"} else {",
									"    pm.test(\"Request failed as expected\", function () {",
									"        pm.expect(response.success).to.be.false;",
									"        pm.expect(response.error).to.be.a('string');",
									"    });",
									"    console.log(\"‚ùå Request failed:\", response.error);",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{auth_token}}",
									"type": "string"
								}
							]
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{base_url}}/market/instruments",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"market",
								"instruments"
							]
						},
						"description": "Get list of available trading instruments via FIX Security List Request.\n\n**Authentication Required**: JWT token in Authorization header\n\n**FIX Message**: Security List Request (x)\n**Connection Used**: Feed session (port 5005)\n\n**Returns**:\n- List of tradeable symbols\n- Symbol metadata (currency, description, etc.)\n- Request/response IDs for tracking"
					},
					"response": [
						{
							"name": "Successful Instruments List",
							"originalRequest": {
								"method": "GET",
								"header": [
									{
										"key": "Authorization",
										"value": "Bearer {{auth_token}}"
									}
								],
								"url": {
									"raw": "{{base_url}}/market/instruments",
									"host": [
										"{{base_url}}"
									],
									"path": [
										"market",
										"instruments"
									]
								}
							},
							"status": "OK",
							"code": 200,
							"_postman_previewlanguage": "json",
							"header": [
								{
									"key": "Content-Type",
									"value": "application/json"
								}
							],
							"cookie": [],
							"body": "{\n    \"success\": true,\n    \"request_id\": \"SLR_1640995200000\",\n    \"response_id\": \"server_response_id\",\n    \"symbols\": [\n        {\n            \"symbol\": \"EUR/USD\",\n            \"security_id\": \"EURUSD\",\n            \"currency\": \"EUR\",\n            \"settle_currency\": \"USD\",\n            \"trade_enabled\": true,\n            \"description\": \"Euro vs US Dollar\"\n        },\n        {\n            \"symbol\": \"GBP/USD\",\n            \"security_id\": \"GBPUSD\",\n            \"currency\": \"GBP\",\n            \"settle_currency\": \"USD\",\n            \"trade_enabled\": true,\n            \"description\": \"British Pound vs US Dollar\"\n        }\n    ],\n    \"message\": \"Retrieved 25 trading instruments\",\n    \"timestamp\": \"2023-12-01T10:30:00Z\"\n}"
						}
					]
				},
				{
					"name": "Get Historical Bars",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"// Test response status",
									"pm.test(\"Status code is 200\", function () {",
									"    pm.response.to.have.status(200);",
									"});",
									"",
									"// Parse response",
									"const response = pm.response.json();",
									"",
									"// Test response structure",
									"pm.test(\"Response has required fields\", function () {",
									"    pm.expect(response).to.have.property('success');",
									"    pm.expect(response).to.have.property('symbol');",
									"    pm.expect(response).to.have.property('period_id');",
									"    pm.expect(response).to.have.property('bars');",
									"});",
									"",
									"// Test if request was successful",
									"if (response.success) {",
									"    pm.test(\"Historical bars retrieved successfully\", function () {",
									"        pm.expect(response.success).to.be.true;",
									"        pm.expect(response.bars).to.be.an('array');",
									"    });",
									"    ",
									"    console.log(\"‚úÖ Retrieved\", response.bars.length, \"historical bars for\", response.symbol);",
									"    console.log(\"üìä Period:\", response.period_id, \"| Price Type:\", response.price_type);",
									"    console.log(\"üìä Request ID:\", response.request_id || 'Not provided');",
									"    ",
									"    // Log date range if available",
									"    if (response.data_from && response.data_to) {",
									"        console.log(\"üìÖ Data Range: \", response.data_from, \"to\", response.data_to);",
									"    }",
									"    ",
									"    // Log first few bars",
									"    if (response.bars.length > 0) {",
									"        console.log(\"üìã Sample bars:\");",
									"        response.bars.slice(0, 3).forEach((bar, index) => {",
									"            console.log(`${index + 1}. ${bar.timestamp}: O=${bar.open_price} H=${bar.high_price} L=${bar.low_price} C=${bar.close_price}`);",
									"        });",
									"        ",
									"        // Validate bar structure",
									"        pm.test(\"Bar data structure is valid\", function () {",
									"            const firstBar = response.bars[0];",
									"            pm.expect(firstBar).to.have.property('timestamp');",
									"            pm.expect(firstBar).to.have.property('open_price');",
									"            pm.expect(firstBar).to.have.property('high_price');",
									"            pm.expect(firstBar).to.have.property('low_price');",
									"            pm.expect(firstBar).to.have.property('close_price');",
									"        });",
									"    }",
									"} else {",
									"    pm.test(\"Request failed as expected\", function () {",
									"        pm.expect(response.success).to.be.false;",
									"        pm.expect(response.error).to.be.a('string');",
									"    });",
									"    console.log(\"‚ùå Request failed:\", response.error);",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{auth_token}}",
									"type": "string"
								}
							]
						},
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"symbol\": \"EUR/USD\",\n  \"timeframe\": \"H1\",\n  \"count\": 50,\n  \"price_type\": \"B\"\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{base_url}}/market/history",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"market",
								"history"
							]
						},
						"description": "Get historical price bars from current time going back in history.\n\n**Authentication Required**: JWT token in Authorization header\n\n**How it works**: Gets current open candle + historical bars going backwards\n\n**Request Parameters**:\n- `symbol` (required): Currency pair (e.g., EUR/USD)\n- `timeframe` (required): S1, S10, M1, M5, M15, M30, H1, H4, D1, W1, MN1\n- `count` (required): Number of bars to retrieve (1-10000)\n- `to_time` (optional): End time for data (defaults to now)\n- `price_type` (optional): \"A\" for Ask, \"B\" for Bid (default: B)\n\n**Examples**:\n- Get last 50 hourly bars: `{\"symbol\": \"EUR/USD\", \"timeframe\": \"H1\", \"count\": 50}`\n- Get last 100 5-min bars: `{\"symbol\": \"EUR/USD\", \"timeframe\": \"M5\", \"count\": 100}`\n\n**Returns**: Array of OHLCV bars with most recent first"
					},
					"response": [
						{
							"name": "Historical Bars - Previous Day",
							"originalRequest": {
								"method": "POST",
								"header": [
									{
										"key": "Authorization",
										"value": "Bearer {{auth_token}}"
									},
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"symbol\": \"EUR/USD\",\n  \"timeframe\": \"H1\",\n  \"count\": 24,\n  \"to_time\": \"2025-08-27T23:59:59.000000\",\n  \"price_type\": \"B\"\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{base_url}}/market/history",
									"host": [
										"{{base_url}}"
									],
									"path": [
										"market",
										"history"
									]
								}
							},
							"status": "OK",
							"code": 200,
							"_postman_previewlanguage": "json",
							"header": [
								{
									"key": "Content-Type",
									"value": "application/json"
								}
							],
							"cookie": [],
							"body": "{\n    \"success\": true,\n    \"request_id\": \"MHR_1756367918500\",\n    \"symbol\": \"EUR/USD\",\n    \"timeframe\": \"H1\",\n    \"price_type\": \"B\",\n    \"from_time\": \"2025-08-27T00:00:00.000000\",\n    \"to_time\": \"2025-08-27T23:00:00.000000\",\n    \"bars\": [\n        {\n            \"timestamp\": \"2025-08-27T23:00:00.000000\",\n            \"open_price\": 1.08945,\n            \"high_price\": 1.08997,\n            \"low_price\": 1.08923,\n            \"close_price\": 1.08976,\n            \"volume\": 1234,\n            \"volume_ex\": 1234.56\n        },\n        {\n            \"timestamp\": \"2025-08-27T22:00:00.000000\",\n            \"open_price\": 1.08912,\n            \"high_price\": 1.08955,\n            \"low_price\": 1.08901,\n            \"close_price\": 1.08945,\n            \"volume\": 987,\n            \"volume_ex\": 987.65\n        }\n    ],\n    \"message\": \"Retrieved 24 historical bars for EUR/USD\",\n    \"timestamp\": \"2025-08-28T07:58:38.591062\"\n}"
						},
						{
							"name": "Successful Historical Bars",
							"originalRequest": {
								"method": "POST",
								"header": [
									{
										"key": "Authorization",
										"value": "Bearer {{auth_token}}"
									},
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"symbol\": \"EUR/USD\",\n  \"period_id\": \"H1\",\n  \"max_bars\": 50,\n  \"end_time\": \"2023-12-01T15:30:00.000000\",\n  \"price_type\": \"B\"\n}"
								},
								"url": {
									"raw": "{{base_url}}/market/history",
									"host": [
										"{{base_url}}"
									],
									"path": [
										"market",
										"history"
									]
								}
							},
							"status": "OK",
							"code": 200,
							"_postman_previewlanguage": "json",
							"header": [
								{
									"key": "Content-Type",
									"value": "application/json"
								}
							],
							"cookie": [],
							"body": "{\n    \"success\": true,\n    \"request_id\": \"MHR_1640995200000\",\n    \"symbol\": \"EUR/USD\",\n    \"period_id\": \"H1\",\n    \"price_type\": \"B\",\n    \"data_from\": \"2023-11-28T10:00:00.000000\",\n    \"data_to\": \"2023-12-01T15:00:00.000000\",\n    \"all_history_from\": \"2020-01-01T00:00:00.000000\",\n    \"all_history_to\": \"2023-12-01T15:30:00.000000\",\n    \"bars\": [\n        {\n            \"timestamp\": \"2023-12-01T14:00:00.000000\",\n            \"open_price\": 1.08945,\n            \"high_price\": 1.08997,\n            \"low_price\": 1.08923,\n            \"close_price\": 1.08976,\n            \"volume\": 1234,\n            \"volume_ex\": 1234.56\n        },\n        {\n            \"timestamp\": \"2023-12-01T13:00:00.000000\",\n            \"open_price\": 1.08912,\n            \"high_price\": 1.08955,\n            \"low_price\": 1.08901,\n            \"close_price\": 1.08945,\n            \"volume\": 987,\n            \"volume_ex\": 987.65\n        }\n    ],\n    \"message\": \"Retrieved 50 historical bars for EUR/USD\",\n    \"timestamp\": \"2023-12-01T15:30:00Z\"\n}"
						},
						{
							"name": "Invalid Symbol Error",
							"originalRequest": {
								"method": "POST",
								"header": [
									{
										"key": "Authorization",
										"value": "Bearer {{auth_token}}"
									},
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"symbol\": \"INVALID/SYMBOL\",\n  \"period_id\": \"H1\",\n  \"max_bars\": 10,\n  \"end_time\": \"2023-12-01T15:30:00.000000\"\n}"
								},
								"url": {
									"raw": "{{base_url}}/market/history",
									"host": [
										"{{base_url}}"
									],
									"path": [
										"market",
										"history"
									]
								}
							},
							"status": "Bad Request",
							"code": 400,
							"_postman_previewlanguage": "json",
							"header": [
								{
									"key": "Content-Type",
									"value": "application/json"
								}
							],
							"cookie": [],
							"body": "{\n    \"message\": \"Failed to retrieve historical bars\",\n    \"error\": \"Request rejected: unknown symbol (Reason code: 1)\"\n}"
						},
						{
							"name": "Validation Error",
							"originalRequest": {
								"method": "POST",
								"header": [
									{
										"key": "Authorization",
										"value": "Bearer {{auth_token}}"
									},
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"symbol\": \"EUR/USD\",\n  \"period_id\": \"INVALID\",\n  \"max_bars\": 50000\n}"
								},
								"url": {
									"raw": "{{base_url}}/market/history",
									"host": [
										"{{base_url}}"
									],
									"path": [
										"market",
										"history"
									]
								}
							},
							"status": "Unprocessable Entity",
							"code": 422,
							"_postman_previewlanguage": "json",
							"header": [
								{
									"key": "Content-Type",
									"value": "application/json"
								}
							],
							"cookie": [],
							"body": "{\n    \"detail\": [\n        {\n            \"loc\": [\"body\", \"period_id\"],\n            \"msg\": \"value is not a valid enumeration member; permitted: 'S1', 'S10', 'M1', 'M5', 'M15', 'M30', 'H1', 'H4', 'D1', 'W1', 'MN1'\",\n            \"type\": \"type_error.enum\"\n        },\n        {\n            \"loc\": [\"body\", \"max_bars\"],\n            \"msg\": \"ensure this value is less than or equal to 10000\",\n            \"type\": \"value_error.number.not_le\"\n        }\n    ]\n}"
						}
					]
				}
			],
			"description": "Market data endpoints for retrieving trading instruments, historical bars, and market information."
		},
		{
			"name": "üéØ Trading System",
			"item": [
				{
					"name": "üìä Order Placement",
					"item": [
						{
							"name": "Market Order - Buy EUR/USD",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// Test response status",
											"pm.test(\"Status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"// Parse response",
											"const response = pm.response.json();",
											"",
											"// Test response structure",
											"pm.test(\"Response has required fields\", function () {",
											"    pm.expect(response).to.have.property('success');",
											"    pm.expect(response).to.have.property('client_order_id');",
											"    pm.expect(response).to.have.property('message');",
											"    pm.expect(response).to.have.property('timestamp');",
											"});",
											"",
											"// Log order results",
											"if (response.success) {",
											"    pm.test(\"Market order placed successfully\", function () {",
											"        pm.expect(response.success).to.be.true;",
											"        pm.expect(response.order_id).to.be.a('string');",
											"    });",
											"    ",
											"    console.log(\"‚úÖ Market Order Successful!\");",
											"    console.log(\"üìã Client Order ID:\", response.client_order_id);",
											"    console.log(\"üÜî Server Order ID:\", response.order_id);",
											"    console.log(\"üí¨ Message:\", response.message);",
											"    ",
											"    // Save order ID for potential cancellation",
											"    if (response.order_id) {",
											"        pm.environment.set(\"last_order_id\", response.order_id);",
											"        pm.environment.set(\"last_client_order_id\", response.client_order_id);",
											"        console.log(\"üíæ Order ID saved for potential operations\");",
											"    }",
											"    ",
											"    // Log execution report if available",
											"    if (response.execution_report) {",
											"        const exec = response.execution_report;",
											"        console.log(\"üìä Execution Report:\");",
											"        console.log(`  Status: ${exec.order_status} | Type: ${exec.exec_type}`);",
											"        console.log(`  Quantity: ${exec.order_qty} | Filled: ${exec.cum_qty} | Remaining: ${exec.leaves_qty}`);",
											"        if (exec.avg_price) console.log(`  Average Price: ${exec.avg_price}`);",
											"    }",
											"} else {",
											"    pm.test(\"Market order failed as expected\", function () {",
											"        pm.expect(response.success).to.be.false;",
											"        pm.expect(response.error).to.be.a('string');",
											"    });",
											"    console.log(\"‚ùå Market Order Failed:\", response.error);",
											"    console.log(\"üí¨ Message:\", response.message);",
											"}",
											"",
											"console.log(\"üìã Full Response:\", JSON.stringify(response, null, 2));"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"auth": {
									"type": "bearer",
									"bearer": [
										{
											"key": "token",
											"value": "{{auth_token}}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"symbol\": \"EUR/USD\",\n  \"side\": \"1\",\n  \"quantity\": 0.01,\n  \"stop_loss\": 1.0800,\n  \"take_profit\": 1.1000,\n  \"comment\": \"Postman market order test\",\n  \"tag\": \"POSTMAN_TEST\",\n  \"magic\": 12345,\n  \"slippage\": 2.0\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{base_url}}/trading/orders/market",
									"host": [
										"{{base_url}}"
									],
									"path": [
										"trading",
										"orders",
										"market"
									]
								},
								"description": "Place a market order for immediate execution at current market price.\n\n**Market Orders:**\n- Execute immediately at best available price\n- No price specification needed\n- Best for quick entry/exit when speed matters more than price\n\n**Parameters:**\n- `symbol`: Currency pair (e.g., \"EUR/USD\")\n- `side`: \"1\" = Buy, \"2\" = Sell\n- `quantity`: Order size (positive number)\n- `stop_loss`: Optional stop loss price\n- `take_profit`: Optional take profit price\n- `comment`: Optional order comment (max 512 chars)\n- `tag`: Optional order tag (max 128 chars)\n- `magic`: Optional magic number for identification\n- `slippage`: Optional slippage tolerance\n\n**FIX Protocol:** Sends New Order Single (D) message with OrdType=1"
							},
							"response": []
						},
						{
							"name": "Limit Order - Buy EUR/USD",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// Test response status",
											"pm.test(\"Status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"const response = pm.response.json();",
											"",
											"pm.test(\"Response has required fields\", function () {",
											"    pm.expect(response).to.have.property('success');",
											"    pm.expect(response).to.have.property('client_order_id');",
											"});",
											"",
											"if (response.success) {",
											"    console.log(\"‚úÖ Limit Order Placed Successfully!\");",
											"    console.log(\"üìã Client Order ID:\", response.client_order_id);",
											"    console.log(\"üÜî Server Order ID:\", response.order_id);",
											"    console.log(\"üí∞ Limit Price: 1.0850 (below current market)\");",
											"    ",
											"    // Save for potential modification/cancellation",
											"    if (response.order_id) {",
											"        pm.environment.set(\"last_limit_order_id\", response.order_id);",
											"        pm.environment.set(\"last_limit_client_order_id\", response.client_order_id);",
											"    }",
											"} else {",
											"    console.log(\"‚ùå Limit Order Failed:\", response.error);",
											"}"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"auth": {
									"type": "bearer",
									"bearer": [
										{
											"key": "token",
											"value": "{{auth_token}}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"symbol\": \"EUR/USD\",\n  \"side\": \"1\",\n  \"quantity\": 0.01,\n  \"price\": 1.0850,\n  \"time_in_force\": \"1\",\n  \"stop_loss\": 1.0800,\n  \"take_profit\": 1.0900,\n  \"comment\": \"Postman limit order - buy below market\",\n  \"tag\": \"LIMIT_TEST\",\n  \"immediate_or_cancel\": false,\n  \"max_visible_qty\": 0.005\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{base_url}}/trading/orders/limit",
									"host": [
										"{{base_url}}"
									],
									"path": [
										"trading",
										"orders",
										"limit"
									]
								},
								"description": "Place a limit order to execute at specified price or better.\n\n**Limit Orders:**\n- Execute only at specified price or better\n- Remain pending until price is reached or order expires\n- Good for precise entry/exit prices\n\n**Parameters:**\n- `price`: Limit price (required)\n- `time_in_force`: \"1\"=GTC, \"3\"=IOC, \"6\"=GTD\n- `expire_time`: Required for GTD orders\n- `max_visible_qty`: For iceberg orders\n- `immediate_or_cancel`: IOC flag for limit orders\n- `market_with_slippage`: Market with slippage protection\n\n**FIX Protocol:** Sends New Order Single (D) with OrdType=2"
							},
							"response": []
						},
						{
							"name": "Stop Order - Sell EUR/USD",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"const response = pm.response.json();",
											"",
											"if (response.success) {",
											"    console.log(\"‚úÖ Stop Order Placed Successfully!\");",
											"    console.log(\"üìã Client Order ID:\", response.client_order_id);",
											"    console.log(\"üõë Stop Price: 1.0800 (below current market)\");",
											"    console.log(\"üí° Will become market order when triggered\");",
											"    ",
											"    if (response.order_id) {",
											"        pm.environment.set(\"last_stop_order_id\", response.order_id);",
											"    }",
											"} else {",
											"    console.log(\"‚ùå Stop Order Failed:\", response.error);",
											"}"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"auth": {
									"type": "bearer",
									"bearer": [
										{
											"key": "token",
											"value": "{{auth_token}}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"symbol\": \"EUR/USD\",\n  \"side\": \"2\",\n  \"quantity\": 0.01,\n  \"stop_price\": 1.0800,\n  \"time_in_force\": \"1\",\n  \"comment\": \"Postman stop order - sell if price drops\"\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{base_url}}/trading/orders/stop",
									"host": [
										"{{base_url}}"
									],
									"path": [
										"trading",
										"orders",
										"stop"
									]
								},
								"description": "Place a stop order that becomes market order when stop price is reached.\n\n**Stop Orders:**\n- Trigger when market reaches stop price\n- Become market orders after trigger\n- Used for stop losses or breakout strategies\n\n**Parameters:**\n- `stop_price`: Stop trigger price (required)\n- Use for stop losses or breakout entries\n- No price protection after trigger\n\n**FIX Protocol:** Sends New Order Single (D) with OrdType=3"
							},
							"response": []
						},
						{
							"name": "Stop-Limit Order - Sell EUR/USD",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"const response = pm.response.json();",
											"",
											"if (response.success) {",
											"    console.log(\"‚úÖ Stop-Limit Order Placed Successfully!\");",
											"    console.log(\"üìã Client Order ID:\", response.client_order_id);",
											"    console.log(\"üõë Stop Price: 1.0800 (trigger level)\");",
											"    console.log(\"üí∞ Limit Price: 1.0790 (execution price)\");",
											"    console.log(\"üí° Will become limit order when triggered\");",
											"    ",
											"    if (response.order_id) {",
											"        pm.environment.set(\"last_stop_limit_order_id\", response.order_id);",
											"    }",
											"} else {",
											"    console.log(\"‚ùå Stop-Limit Order Failed:\", response.error);",
											"}"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"auth": {
									"type": "bearer",
									"bearer": [
										{
											"key": "token",
											"value": "{{auth_token}}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"symbol\": \"EUR/USD\",\n  \"side\": \"2\",\n  \"quantity\": 0.01,\n  \"stop_price\": 1.0800,\n  \"price\": 1.0790,\n  \"time_in_force\": \"1\",\n  \"comment\": \"Postman stop-limit order with price protection\",\n  \"immediate_or_cancel\": false\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{base_url}}/trading/orders/stop-limit",
									"host": [
										"{{base_url}}"
									],
									"path": [
										"trading",
										"orders",
										"stop-limit"
									]
								},
								"description": "Place a stop-limit order with trigger and execution price protection.\n\n**Stop-Limit Orders:**\n- Trigger when market reaches stop price\n- Become limit orders at specified limit price\n- Provide price protection after trigger\n\n**Parameters:**\n- `stop_price`: Stop trigger price (required)\n- `price`: Limit price after trigger (required)\n- Best of both worlds: trigger + price protection\n\n**FIX Protocol:** Sends New Order Single (D) with OrdType=4"
							},
							"response": []
						},
						{
							"name": "Generic Order - All Types",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"const response = pm.response.json();",
											"",
											"if (response.success) {",
											"    console.log(\"‚úÖ Generic Order Placed Successfully!\");",
											"    console.log(\"üìã Order Type: Limit (2)\");",
											"    console.log(\"üí∞ Price: 1.0860\");",
											"} else {",
											"    console.log(\"‚ùå Generic Order Failed:\", response.error);",
											"}"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"auth": {
									"type": "bearer",
									"bearer": [
										{
											"key": "token",
											"value": "{{auth_token}}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"symbol\": \"EUR/USD\",\n  \"order_type\": \"2\",\n  \"side\": \"1\",\n  \"quantity\": 0.01,\n  \"price\": 1.0860,\n  \"stop_price\": null,\n  \"time_in_force\": \"1\",\n  \"comment\": \"Generic endpoint test - limit order\"\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{base_url}}/trading/orders",
									"host": [
										"{{base_url}}"
									],
									"path": [
										"trading",
										"orders"
									]
								},
								"description": "Generic order placement endpoint - accepts any order type.\n\n**Order Types:**\n- \"1\" = Market Order\n- \"2\" = Limit Order\n- \"3\" = Stop Order\n- \"4\" = Stop-Limit Order\n\n**Recommendation:** Use specific endpoints for better validation and documentation."
							},
							"response": []
						}
					],
					"description": "Order placement endpoints for all trading order types."
				},
				{
					"name": "üîß Order Management",
					"item": [
						{
							"name": "Cancel Order",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"const response = pm.response.json();",
											"",
											"if (response.success) {",
											"    console.log(\"‚úÖ Order Cancel Request Sent!\");",
											"    console.log(\"üìã Cancel Order ID:\", response.client_order_id);",
											"    console.log(\"üéØ Target Order:\", response.order_id);",
											"    console.log(\"üí¨ Message:\", response.message);",
											"} else {",
											"    console.log(\"‚ùå Order Cancel Failed:\", response.error);",
											"}"
										],
										"type": "text/javascript"
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"// Check if we have a saved order ID to cancel",
											"const lastOrderId = pm.environment.get(\"last_limit_order_id\");",
											"if (!lastOrderId) {",
											"    console.warn(\"‚ö†Ô∏è  No saved order ID found. Place a limit order first to test cancellation.\");",
											"    console.warn(\"üí° Using example order ID 'ORDER123' for demonstration.\");",
											"}"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"auth": {
									"type": "bearer",
									"bearer": [
										{
											"key": "token",
											"value": "{{auth_token}}",
											"type": "string"
										}
									]
								},
								"method": "DELETE",
								"header": [],
								"url": {
									"raw": "{{base_url}}/trading/orders/{{last_limit_order_id}}?symbol=EUR/USD&side=1&original_client_order_id={{last_limit_client_order_id}}",
									"host": [
										"{{base_url}}"
									],
									"path": [
										"trading",
										"orders",
										"{{last_limit_order_id}}"
									],
									"query": [
										{
											"key": "symbol",
											"value": "EUR/USD",
											"description": "Currency pair of original order"
										},
										{
											"key": "side",
											"value": "1",
											"description": "Side of original order (1=Buy, 2=Sell)"
										},
										{
											"key": "original_client_order_id",
											"value": "{{last_limit_client_order_id}}",
											"description": "Optional: Original client order ID"
										}
									]
								},
								"description": "Cancel a pending order by server order ID.\n\n**Requirements:**\n- Order must be in pending status (not filled/cancelled)\n- Must provide original order details for validation\n\n**Parameters:**\n- `order_id`: Server-assigned order ID (in URL path)\n- `symbol`: Currency pair of original order\n- `side`: Original order side (\"1\"=Buy, \"2\"=Sell)\n- `original_client_order_id`: Optional client order ID\n\n**FIX Protocol:** Sends Order Cancel Request (F) message\n\n**Note:** This uses the saved order ID from previous limit order. Place a limit order first!"
							},
							"response": []
						},
						{
							"name": "Modify Order",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"const response = pm.response.json();",
											"",
											"if (response.success) {",
											"    console.log(\"‚úÖ Order Modify Request Sent!\");",
											"    console.log(\"üìã Modify Order ID:\", response.client_order_id);",
											"    console.log(\"üéØ Target Order:\", response.order_id);",
											"    console.log(\"üí∞ New Price: 1.0870\");",
											"    console.log(\"üìä New Quantity: 0.02\");",
											"} else {",
											"    console.log(\"‚ùå Order Modify Failed:\", response.error);",
											"}"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"auth": {
									"type": "bearer",
									"bearer": [
										{
											"key": "token",
											"value": "{{auth_token}}",
											"type": "string"
										}
									]
								},
								"method": "PUT",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"symbol\": \"EUR/USD\",\n  \"side\": \"1\",\n  \"original_client_order_id\": \"{{last_limit_client_order_id}}\",\n  \"new_quantity\": 0.02,\n  \"new_price\": 1.0870,\n  \"new_stop_loss\": 1.0820,\n  \"new_take_profit\": 1.0920,\n  \"new_comment\": \"Modified via Postman - increased size and price\",\n  \"leaves_qty\": 0.01\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{base_url}}/trading/orders/{{last_limit_order_id}}",
									"host": [
										"{{base_url}}"
									],
									"path": [
										"trading",
										"orders",
										"{{last_limit_order_id}}"
									]
								},
								"description": "Modify a pending order's parameters.\n\n**Modifiable Fields:**\n- `new_quantity`: New order size\n- `new_price`: New limit price\n- `new_stop_price`: New stop price\n- `new_stop_loss`: New stop loss level\n- `new_take_profit`: New take profit level\n- `new_time_in_force`: New time in force\n- `new_expire_time`: New expiration time\n- `new_comment`: New order comment\n- `new_tag`: New order tag\n- `leaves_qty`: Expected remaining qty (validation)\n\n**Requirements:**\n- At least one field must be modified\n- Order must be in pending status\n\n**FIX Protocol:** Sends Order Cancel/Replace Request (G)\n\n**Note:** Uses saved order ID from limit order test."
							},
							"response": []
						}
					],
					"description": "Order management endpoints for cancelling and modifying pending orders."
				},
				{
					"name": "üìä Order Examples",
					"item": [
						{
							"name": "Order with Stop Loss & Take Profit",
							"request": {
								"auth": {
									"type": "bearer",
									"bearer": [
										{
											"key": "token",
											"value": "{{auth_token}}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"symbol\": \"EUR/USD\",\n  \"side\": \"1\",\n  \"quantity\": 0.01,\n  \"stop_loss\": 1.0800,\n  \"take_profit\": 1.1000,\n  \"comment\": \"Market order with risk management\",\n  \"tag\": \"SL_TP_TEST\"\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{base_url}}/trading/orders/market",
									"host": [
										"{{base_url}}"
									],
									"path": [
										"trading",
										"orders",
										"market"
									]
								},
								"description": "Example: Market order with stop loss and take profit.\n\n**Risk Management:**\n- Stop Loss: 1.0800 (limits downside risk)\n- Take Profit: 1.1000 (secures profit target)\n- Automatic execution when levels are hit"
							},
							"response": []
						},
						{
							"name": "Limit Order with Time in Force",
							"request": {
								"auth": {
									"type": "bearer",
									"bearer": [
										{
											"key": "token",
											"value": "{{auth_token}}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"symbol\": \"GBP/USD\",\n  \"side\": \"2\",\n  \"quantity\": 0.02,\n  \"price\": 1.2500,\n  \"time_in_force\": \"6\",\n  \"expire_time\": \"2024-12-31T23:59:59\",\n  \"comment\": \"Good Till Date limit order\",\n  \"immediate_or_cancel\": false\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{base_url}}/trading/orders/limit",
									"host": [
										"{{base_url}}"
									],
									"path": [
										"trading",
										"orders",
										"limit"
									]
								},
								"description": "Example: Limit order with Good Till Date (GTD) time in force.\n\n**Time in Force Options:**\n- \"1\" = Good Till Cancel (GTC) - Default\n- \"3\" = Immediate or Cancel (IOC)\n- \"6\" = Good Till Date (GTD) - Requires expire_time"
							},
							"response": []
						},
						{
							"name": "Iceberg Order (Hidden Quantity)",
							"request": {
								"auth": {
									"type": "bearer",
									"bearer": [
										{
											"key": "token",
											"value": "{{auth_token}}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"symbol\": \"EUR/USD\",\n  \"side\": \"1\",\n  \"quantity\": 0.10,\n  \"price\": 1.0850,\n  \"max_visible_qty\": 0.01,\n  \"comment\": \"Iceberg order - only 0.01 visible at a time\",\n  \"tag\": \"ICEBERG_TEST\"\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{base_url}}/trading/orders/limit",
									"host": [
										"{{base_url}}"
									],
									"path": [
										"trading",
										"orders",
										"limit"
									]
								},
								"description": "Example: Iceberg order with hidden quantity.\n\n**Iceberg Orders:**\n- Total quantity: 0.10\n- Visible quantity: 0.01\n- Hides large orders to reduce market impact\n- Reveals more quantity as visible portion is filled"
							},
							"response": []
						}
					],
					"description": "Example orders demonstrating advanced features and use cases."
				},
				{
					"name": "üè• Trading Health Check",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 200\", function () {",
									"    pm.response.to.have.status(200);",
									"});",
									"",
									"const response = pm.response.json();",
									"",
									"pm.test(\"Trading service is healthy\", function () {",
									"    pm.expect(response.status).to.eql(\"healthy\");",
									"    pm.expect(response.service).to.eql(\"trading\");",
									"});",
									"",
									"console.log(\"üíö Trading Service Status:\", response.status);",
									"console.log(\"üéØ Service:\", response.service);",
									"console.log(\"üí¨ Message:\", response.message);"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{base_url}}/trading/health",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"trading",
								"health"
							]
						},
						"description": "Health check for trading service - no authentication required."
					},
					"response": [
						{
							"name": "Trading Service Healthy",
							"originalRequest": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{base_url}}/trading/health",
									"host": [
										"{{base_url}}"
									],
									"path": [
										"trading",
										"health"
									]
								}
							},
							"status": "OK",
							"code": 200,
							"_postman_previewlanguage": "json",
							"header": [
								{
									"key": "Content-Type",
									"value": "application/json"
								}
							],
							"cookie": [],
							"body": "{\n    \"status\": \"healthy\",\n    \"service\": \"trading\",\n    \"message\": \"Trading service is operational\"\n}"
						}
					]
				}
			],
			"description": "Complete trading system with all order types, management capabilities, and advanced features.\n\n## üéØ Order Types Available\n1. **Market Orders**: Immediate execution at current market price\n2. **Limit Orders**: Execute at specified price or better\n3. **Stop Orders**: Trigger at stop price, then become market order\n4. **Stop-Limit Orders**: Trigger at stop price, then become limit order\n\n## üõ°Ô∏è Advanced Features\n- **Stop Loss & Take Profit**: Automatic risk management\n- **Time in Force**: GTC, IOC, GTD options\n- **Iceberg Orders**: Hide large order quantities\n- **Order Metadata**: Comments, tags, magic numbers\n- **Order Management**: Cancel and modify pending orders\n\n## üîß Order Management\n- **Cancel Orders**: Cancel pending orders by ID\n- **Modify Orders**: Change price, quantity, stop levels\n- **Order Tracking**: Client and server order IDs\n\n## üîí Security & Validation\n- **JWT Authentication**: Required for all trading endpoints\n- **Input Validation**: Comprehensive parameter validation\n- **FIX Protocol**: Full integration with New Order Single (D) messages\n- **Process Isolation**: Thread-safe QuickFIX implementation\n\n## üìä Testing Workflow\n1. **Login** to get authentication token\n2. **Place Orders** using various order types\n3. **Monitor** via session status\n4. **Manage Orders** (cancel/modify as needed)\n5. **Check Health** of trading service\n\n## üí° Tips\n- Order IDs are automatically saved for management operations\n- Use realistic prices based on current market levels\n- Test with small quantities (0.01) for safety\n- Check execution reports for order status details"
		},
		{
			"name": "üîå WebSocket Orderbook",
			"item": [
				{
					"name": "WebSocket Status",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"// Test response status",
									"pm.test(\"Status code is 200\", function () {",
									"    pm.response.to.have.status(200);",
									"});",
									"",
									"// Parse response",
									"const response = pm.response.json();",
									"",
									"// Test response structure",
									"pm.test(\"Response has required fields\", function () {",
									"    pm.expect(response).to.have.property('success');",
									"    pm.expect(response).to.have.property('user_id');",
									"    pm.expect(response).to.have.property('websocket_connected');",
									"    pm.expect(response).to.have.property('active_subscriptions');",
									"});",
									"",
									"// Log WebSocket status",
									"if (response.success) {",
									"    console.log(\"‚úÖ WebSocket Status Retrieved\");",
									"    console.log(\"üë§ User ID:\", response.user_id);",
									"    console.log(\"üîå WebSocket Connected:\", response.websocket_connected);",
									"    console.log(\"üìä Active Subscriptions:\", response.active_subscriptions.length);",
									"    console.log(\"üåê Total Connections:\", response.total_connections);",
									"    ",
									"    if (response.active_subscriptions.length > 0) {",
									"        console.log(\"üìã Subscribed to:\", response.active_subscriptions.join(', '));",
									"    } else {",
									"        console.log(\"üì≠ No active subscriptions\");",
									"    }",
									"} else {",
									"    console.log(\"‚ùå Failed to get WebSocket status\");",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{auth_token}}",
									"type": "string"
								}
							]
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{base_url}}/ws/orderbook/status",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"ws",
								"orderbook",
								"status"
							]
						},
						"description": "Get WebSocket connection status and active subscriptions.\n\n**Authentication Required**: JWT token in Authorization header\n\n**Returns**:\n- WebSocket connection status\n- Active orderbook subscriptions\n- Total WebSocket connections\n- User identification"
					},
					"response": [
						{
							"name": "WebSocket Status - Connected",
							"originalRequest": {
								"method": "GET",
								"header": [
									{
										"key": "Authorization",
										"value": "Bearer {{auth_token}}"
									}
								],
								"url": {
									"raw": "{{base_url}}/ws/orderbook/status",
									"host": [
										"{{base_url}}"
									],
									"path": [
										"ws",
										"orderbook",
										"status"
									]
								}
							},
							"status": "OK",
							"code": 200,
							"_postman_previewlanguage": "json",
							"header": [
								{
									"key": "Content-Type",
									"value": "application/json"
								}
							],
							"cookie": [],
							"body": "{\n    \"success\": true,\n    \"user_id\": \"trader123\",\n    \"websocket_connected\": true,\n    \"active_subscriptions\": [\"EUR/USD\", \"GBP/USD\"],\n    \"total_connections\": 3,\n    \"message\": \"WebSocket status for user trader123\"\n}"
						},
						{
							"name": "WebSocket Status - Not Connected",
							"originalRequest": {
								"method": "GET",
								"header": [
									{
										"key": "Authorization",
										"value": "Bearer {{auth_token}}"
									}
								],
								"url": {
									"raw": "{{base_url}}/ws/orderbook/status",
									"host": [
										"{{base_url}}"
									],
									"path": [
										"ws",
										"orderbook",
										"status"
									]
								}
							},
							"status": "OK",
							"code": 200,
							"_postman_previewlanguage": "json",
							"header": [
								{
									"key": "Content-Type",
									"value": "application/json"
								}
							],
							"cookie": [],
							"body": "{\n    \"success\": true,\n    \"user_id\": \"trader123\",\n    \"websocket_connected\": false,\n    \"active_subscriptions\": [],\n    \"total_connections\": 0,\n    \"message\": \"WebSocket status for user trader123\"\n}"
						}
					]
				},
				{
					"name": "WebSocket Connection Guide",
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{base_url}}/docs#/WebSocket",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"docs"
							],
							"hash": "#/WebSocket"
						},
						"description": "**WebSocket Orderbook Connection Guide**\n\n## Connection URL\n```\nws://localhost:8000/ws/orderbook?token=YOUR_JWT_TOKEN\n```\n\n## Message Format\nAll messages are JSON objects with a `type` field:\n\n### Subscribe to Orderbook\n```json\n{\n  \"type\": \"subscribe\",\n  \"symbol\": \"EUR/USD\",\n  \"levels\": 5,\n  \"md_req_id\": \"optional_custom_id\"\n}\n```\n\n### Unsubscribe from Orderbook\n```json\n{\n  \"type\": \"unsubscribe\",\n  \"symbol\": \"EUR/USD\",\n  \"md_req_id\": \"optional_id_to_cancel\"\n}\n```\n\n## Received Messages\n\n### Orderbook Data\n```json\n{\n  \"type\": \"orderbook\",\n  \"symbol\": \"EUR/USD\",\n  \"request_id\": \"OB_EUR/USD_1640995200000\",\n  \"data\": {\n    \"symbol\": \"EUR/USD\",\n    \"timestamp\": \"2023-12-01T10:30:15\",\n    \"best_bid\": 1.08945,\n    \"best_ask\": 1.08955,\n    \"mid_price\": 1.08950,\n    \"spread\": 0.00010,\n    \"spread_bps\": 0.92,\n    \"bids\": [\n      {\"price\": 1.08945, \"size\": 100000, \"level\": 1},\n      {\"price\": 1.08940, \"size\": 200000, \"level\": 2}\n    ],\n    \"asks\": [\n      {\"price\": 1.08955, \"size\": 150000, \"level\": 1},\n      {\"price\": 1.08960, \"size\": 100000, \"level\": 2}\n    ]\n  },\n  \"timestamp\": \"2023-12-01T10:30:15.123456\"\n}\n```\n\n### Success/Error Messages\n```json\n{\n  \"type\": \"success\",\n  \"message\": \"Subscribed to orderbook for EUR/USD\",\n  \"symbol\": \"EUR/USD\",\n  \"md_req_id\": \"OB_EUR/USD_1640995200000\"\n}\n```\n\n```json\n{\n  \"type\": \"error\",\n  \"error\": \"Failed to subscribe to INVALID/SYMBOL: unknown symbol\",\n  \"symbol\": \"INVALID/SYMBOL\"\n}\n```\n\n### Heartbeat\n```json\n{\n  \"type\": \"heartbeat\",\n  \"timestamp\": \"2023-12-01T10:30:15.123456\"\n}\n```\n\n## Recommended WebSocket Clients\n- **Browser**: WebSocket King Chrome Extension\n- **Command Line**: `wscat -c \"ws://localhost:8000/ws/orderbook?token=YOUR_TOKEN\"`\n- **Python**: `websockets` library\n- **JavaScript**: Native WebSocket API\n\n## Features\n- **Real-time Updates**: Live orderbook streaming\n- **Multiple Symbols**: Subscribe to multiple instruments\n- **Automatic Cleanup**: FIX subscriptions cancelled on disconnect\n- **Error Handling**: Comprehensive error messages\n- **Authentication**: JWT token-based security"
					}
				}
			],
			"description": "WebSocket endpoints for real-time orderbook streaming. Use external WebSocket clients to connect and subscribe to live market data."
		},
		{
			"name": "üè• Health & System",
			"item": [
				{
					"name": "Root Endpoint",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 200\", function () {",
									"    pm.response.to.have.status(200);",
									"});",
									"",
									"const response = pm.response.json();",
									"",
									"pm.test(\"API is running\", function () {",
									"    pm.expect(response.message).to.include(\"running\");",
									"});",
									"",
									"console.log(\"üöÄ API Status:\", response.message);"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{base_url}}/",
							"host": [
								"{{base_url}}"
							],
							"path": [
								""
							]
						},
						"description": "Basic API status check - no authentication required."
					},
					"response": [
						{
							"name": "API Running",
							"originalRequest": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{base_url}}/",
									"host": [
										"{{base_url}}"
									],
									"path": [
										""
									]
								}
							},
							"status": "OK",
							"code": 200,
							"_postman_previewlanguage": "json",
							"header": [
								{
									"key": "Content-Type",
									"value": "application/json"
								}
							],
							"cookie": [],
							"body": "{\n    \"message\": \"FIX API Adapter is running\"\n}"
						}
					]
				},
				{
					"name": "Health Check",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 200\", function () {",
									"    pm.response.to.have.status(200);",
									"});",
									"",
									"const response = pm.response.json();",
									"",
									"pm.test(\"Health status is healthy\", function () {",
									"    pm.expect(response.status).to.eql(\"healthy\");",
									"});",
									"",
									"console.log(\"üíö Health Status:\", response.status);"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{base_url}}/health",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"health"
							]
						},
						"description": "Health check endpoint for monitoring - no authentication required."
					},
					"response": [
						{
							"name": "Healthy",
							"originalRequest": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{base_url}}/health",
									"host": [
										"{{base_url}}"
									],
									"path": [
										"health"
									]
								}
							},
							"status": "OK",
							"code": 200,
							"_postman_previewlanguage": "json",
							"header": [
								{
									"key": "Content-Type",
									"value": "application/json"
								}
							],
							"cookie": [],
							"body": "{\n    \"status\": \"healthy\"\n}"
						}
					]
				},
				{
					"name": "API Documentation",
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{base_url}}/docs",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"docs"
							]
						},
						"description": "FastAPI automatic documentation (Swagger UI) - opens in browser."
					}
				}
			],
			"description": "System health and documentation endpoints."
		}
	],
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"type": "text/javascript",
				"exec": [
					"// Global pre-request script",
					"console.log(\"üåê Making request to:\", pm.request.url.toString());",
					"",
					"// Check if auth token exists for protected endpoints",
					"const authToken = pm.environment.get(\"auth_token\");",
					"const isProtectedEndpoint = pm.request.url.toString().includes(\"/session\") || pm.request.url.toString().includes(\"/market\") || pm.request.url.toString().includes(\"/ws\") || pm.request.url.toString().includes(\"/trading\");",
					"",
					"if (isProtectedEndpoint && !authToken) {",
					"    console.warn(\"‚ö†Ô∏è  This endpoint requires authentication. Run the Login request first.\");",
					"    console.warn(\"üéØ Trading endpoints require valid JWT token for security.\");",
					"}"
				]
			}
		},
		{
			"listen": "test",
			"script": {
				"type": "text/javascript",
				"exec": [
					"// Global test script",
					"console.log(\"üì° Response received from:\", pm.request.url.toString());",
					"console.log(\"üìä Response time:\", pm.response.responseTime + \"ms\");",
					"console.log(\"üìã Response size:\", pm.response.responseSize + \" bytes\");",
					"",
					"// Test response time",
					"pm.test(\"Response time is reasonable\", function () {",
					"    pm.expect(pm.response.responseTime).to.be.below(5000);",
					"});",
					"",
					"// Test response format",
					"pm.test(\"Response is JSON\", function () {",
					"    pm.response.to.be.json;",
					"});"
				]
			}
		}
	],
	"variable": [
		{
			"key": "base_url",
			"value": "http://localhost:8000",
			"type": "string"
		},
		{
			"key": "ws_base_url",
			"value": "ws://localhost:8000",
			"type": "string"
		},
		{
			"key": "username",
			"value": "your_fix_username",
			"type": "string"
		},
		{
			"key": "password",
			"value": "your_fix_password",
			"type": "string"
		},
		{
			"key": "device_id",
			"value": "postman_testing",
			"type": "string"
		}
	]
}
